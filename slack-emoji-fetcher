#!/usr/bin/env bash
# This script was generated by bashly 0.8.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  set -eo pipefail

  curl_opts="-s"
  if [[ -n "${args[--debug]}" ]]; then

    set -x
    curl_opts="-v ${curl_opts}"
  fi

  if ! command -v "jq" &> /dev/null; then
    echo "$(red_bold [ERR]) jq could not be located. Install using the relevant command:"
    echo "$(red_bold [ERR])   MacOS: $ brew update && brew install jq"
    echo "$(red_bold [ERR])   Linux: $ apt-get install jq"
  fi

  payload=$(
    jq -nc \
      --arg     token "${args[--token]}" \
      --argjson count "${args[--count]}" \
      '{
        token: $token,

        count: $count
      }'
  )

  while true; do
    result=$(
      curl ${curl_opts} --compressed "https://edgeapi.slack.com/cache/${args[--workspace-id]}/emojis/list?fp=97" \
        -H "cookie: d=${args[--cookie]};" \
        --data-raw "${payload}"

    )

    if [[ $(echo "${result}" | jq -r ".ok") == false ]]; then
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) request could not be completed: ${error}"
      exit 1
    fi

    echo "${result}"  | jq -r '.results[] | select(.is_alias == null and (.value | type != "object")) | .value' | while read -r line; do

      name=$(basename $(dirname "${line}"))
      path="${args[--destination]}/${name}.${line##*.}"
      echo -n "$(green [INF]) saving :${name}: to ${path}..."
      if [[ -n ${args[--dry-run]} ]]; then

        echo 'skipping!'
        continue
      fi

      curl ${curl_opts} -o  "${path}" "${line}"

      echo 'done!'
    done

    marker=$(echo "${result}" | jq -r ".next_marker")
    [[ "${marker}" == "null" ]] && break

    payload=$(echo "${payload}" | jq --arg marker "${marker}" '. + { marker: $marker }')
  done

  echo "$(green [INF]) all done; exiting ..."
  exit 0
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
slack_emoji_fetcher_usage() {
  if [[ -n $long_usage ]]; then
    printf "slack-emoji-fetcher - Download custom emojis from any Slack workspace.\n"
    echo

  else
    printf "slack-emoji-fetcher - Download custom emojis from any Slack workspace.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  slack-emoji-fetcher [options]\n"
  printf "  slack-emoji-fetcher --help | -h\n"
  printf "  slack-emoji-fetcher --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --workspace-id ID (required)"
    printf "    The unique identifier for your Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --token TOKEN (required)"
    printf "    The unique token associated with the API requests for the target Slack\n    workspace.\n"
    echo

    # :flag.usage
    echo "  --cookie COOKIE (required)"
    printf "    The value of the \"d\" cookie header used to authenticate with the target\n    Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --count COUNT"
    printf "    The number of results to page through at a time.\n"
    printf "    Default: 10\n"
    echo

    # :flag.usage
    echo "  --destination DESTINATION"
    printf "    The directory in which emojis will be saved.\n"
    printf "    Default: .\n"
    echo

    # :flag.usage
    echo "  --dry-run"
    printf "    Queries the emoji endpoint, but does not save the results to disk.\n"
    echo

    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash while also activating high verbosity for curl\n    commands. Useful for troubleshooting requests.\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    printf "  slack-emoji-fetcher --workspace-id=XXX --token=XXX --cookie=XXX\n"
    printf "  slack-emoji-fetcher --workspace-id=XXX --token=XXX --cookie=XXX --debug\n  --dry-run\n"
    printf "  slack-emoji-fetcher --workspace-id=XXX --token=XXX --cookie=XXX --count=100\n  --destination=\"${HOME}/emojis\" --dry-run\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    slack_emoji_fetcher_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --workspace-id )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--workspace-id]="$2"
        shift
        shift
      else
        printf "%s\n" "--workspace-id requires an argument: --workspace-id ID"
        exit 1
      fi
      ;;

    # :flag.case
    --token )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--token]="$2"
        shift
        shift
      else
        printf "%s\n" "--token requires an argument: --token TOKEN"
        exit 1
      fi
      ;;

    # :flag.case
    --cookie )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--cookie]="$2"
        shift
        shift
      else
        printf "%s\n" "--cookie requires an argument: --cookie COOKIE"
        exit 1
      fi
      ;;

    # :flag.case
    --count )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_integer "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--count COUNT" "$(validate_integer "$2")"
          exit 1
        fi

        args[--count]="$2"
        shift
        shift
      else
        printf "%s\n" "--count requires an argument: --count COUNT"
        exit 1
      fi
      ;;

    # :flag.case
    --destination )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_dir_exists "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--destination DESTINATION" "$(validate_dir_exists "$2")"
          exit 1
        fi

        args[--destination]="$2"
        shift
        shift
      else
        printf "%s\n" "--destination requires an argument: --destination DESTINATION"
        exit 1
      fi
      ;;

    # :flag.case
    --dry-run )

      # :flag.case_no_arg
      args[--dry-run]=1
      shift
      ;;

    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args[--workspace-id]+x} ]]; then
    printf "missing required flag: --workspace-id ID\n"
    exit 1
  fi
  if [[ -z ${args[--token]+x} ]]; then
    printf "missing required flag: --token TOKEN\n"
    exit 1
  fi
  if [[ -z ${args[--cookie]+x} ]]; then
    printf "missing required flag: --cookie COOKIE\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--count]:-} ]] || args[--count]="10"
  [[ -n ${args[--destination]:-} ]] || args[--destination]="."

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
