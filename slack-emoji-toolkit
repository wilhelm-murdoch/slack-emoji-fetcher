#!/usr/bin/env bash
# This script was generated by bashly 0.8.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n"
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
slack_emoji_toolkit_usage() {
  if [[ -n $long_usage ]]; then
    printf "slack-emoji-toolkit - Bulk manage emojis for your Slack workspace.\n"
    echo

  else
    printf "slack-emoji-toolkit - Bulk manage emojis for your Slack workspace.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  slack-emoji-toolkit [command]\n"
  printf "  slack-emoji-toolkit [command] --help | -h\n"
  printf "  slack-emoji-toolkit --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  upload     Bulk upload locally-stored emojis to the specified Slack workspace. This is a function that requires additional permissions."
  echo "  delete     Delete individual, groups, or all emojis from the specified Slack workspace. This is a function that requires additional permissions."
  echo "  download   Download all custom emoji associated with the given workspace id."
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
slack_emoji_toolkit_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "slack-emoji-toolkit upload - Bulk upload locally-stored emojis to the specified Slack workspace. This is a function that requires additional permissions.\n"
    echo

  else
    printf "slack-emoji-toolkit upload - Bulk upload locally-stored emojis to the specified Slack workspace. This is a function that requires additional permissions.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  slack-emoji-toolkit upload [options]\n"
  printf "  slack-emoji-toolkit upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --workspace-domain DOMAIN (required)"
    printf "    The unique subdomain associated with the target workspace.\n"
    echo

    # :flag.usage
    echo "  --workspace-id ID (required)"
    printf "    The unique identifier for your Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --token TOKEN (required)"
    printf "    The unique token associated with the API requests for the target Slack\n    workspace.\n"
    echo

    # :flag.usage
    echo "  --cookie COOKIE (required)"
    printf "    The value of the \"d\" cookie header used to authenticate with the target\n    Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --source SOURCE"
    printf "    The source directory for your emojis. Defaults to the present working\n    directory.\n"
    printf "    Default: .\n"
    echo

    # :flag.usage
    echo "  --prefix PREFIX"
    printf "    Add a prefix to the name of all uploaded emojis.\n"
    echo

    # :flag.usage
    echo "  --suffix SUFFIX"
    printf "    Add a suffix to the name of all uploaded emojis.\n"
    echo

    # :flag.usage
    echo "  --dry-run"
    printf "    Query, but make no destructive changes.\n"
    echo

    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash while also activating high verbosity for curl\n    commands. Useful for troubleshooting requests.\n"
    echo

  fi
}

# :command.usage
slack_emoji_toolkit_delete_usage() {
  if [[ -n $long_usage ]]; then
    printf "slack-emoji-toolkit delete - Delete individual, groups, or all emojis from the specified Slack workspace. This is a function that requires additional permissions.\n"
    echo

  else
    printf "slack-emoji-toolkit delete - Delete individual, groups, or all emojis from the specified Slack workspace. This is a function that requires additional permissions.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  slack-emoji-toolkit delete [options]\n"
  printf "  slack-emoji-toolkit delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --workspace-domain DOMAIN (required)"
    printf "    The unique subdomain associated with the target workspace.\n"
    echo

    # :flag.usage
    echo "  --token TOKEN (required)"
    printf "    The unique token associated with the API requests for the target Slack\n    workspace.\n"
    echo

    # :flag.usage
    echo "  --cookie COOKIE (required)"
    printf "    The value of the \"d\" cookie header used to authenticate with the target\n    Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --query QUERIES (repeatable)"
    printf "    Filter emojis that match the specified term. Cannot be used with --name.\n"
    echo

    # :flag.usage
    echo "  --user-id USERS (repeatable)"
    printf "    Filter emojis submitted by a specific user, or users. Cannot be used with\n    --name.\n"
    echo

    # :flag.usage
    echo "  --name NAME"
    printf "    Delete the emoji with the specified name. Cannot be used with --filter.\n"
    echo

    # :flag.usage
    echo "  --count COUNT"
    printf "    The number of results to page through at a time.\n"
    printf "    Default: 10\n"
    echo

    # :flag.usage
    echo "  --nuke-from-orbit"
    printf "    Skip individual confirmation of delete operations. This is a highly\n    destructive action. Be sure to download your emoji first!\n"
    echo

    # :flag.usage
    echo "  --dry-run"
    printf "    Query, but make no destructive changes.\n"
    echo

    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash while also activating high verbosity for curl\n    commands. Useful for troubleshooting requests.\n"
    echo

  fi
}

# :command.usage
slack_emoji_toolkit_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "slack-emoji-toolkit download - Download all custom emoji associated with the given workspace id.\n"
    echo

  else
    printf "slack-emoji-toolkit download - Download all custom emoji associated with the given workspace id.\n"
    echo

  fi

  printf "Usage:\n"
  printf "  slack-emoji-toolkit download [options]\n"
  printf "  slack-emoji-toolkit download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "Options:\n"

    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_flags
    # :flag.usage
    echo "  --workspace-id ID (required)"
    printf "    The unique identifier for your Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --token TOKEN (required)"
    printf "    The unique token associated with the API requests for the target Slack\n    workspace.\n"
    echo

    # :flag.usage
    echo "  --cookie COOKIE (required)"
    printf "    The value of the \"d\" cookie header used to authenticate with the target\n    Slack workspace.\n"
    echo

    # :flag.usage
    echo "  --count COUNT"
    printf "    The number of results to page through at a time.\n"
    printf "    Default: 10\n"
    echo

    # :flag.usage
    echo "  --destination DESTINATION"
    printf "    The directory in which emojis will be saved.\n"
    printf "    Default: .\n"
    echo

    # :flag.usage
    echo "  --dry-run"
    printf "    Query, but make no destructive changes.\n"
    echo

    # :flag.usage
    echo "  --debug"
    printf "    Use to \`set -x\` for Bash while also activating high verbosity for curl\n    commands. Useful for troubleshooting requests.\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/utils.sh
confirm(){
  read -r -p "${1:-Are you sure? [y/N]}: " response
  case "${response}" in
    [yY][eE][sS]|[yY]) true ;;
    *) false ;;
  esac
}

join () {
  local IFS="${1}"
  shift
  echo "${*}"
}

# src/lib/validations/validate_dir_exists.sh
validate_dir_exists() {
  [[ -d "$1" ]] || echo "must be an existing directory"
}

# src/lib/validations/validate_file_exists.sh
validate_file_exists() {
  [[ -f "$1" ]] || echo "must be an existing file"
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# src/lib/validations/validate_not_empty.sh
validate_not_empty() {
  [[ -z "$1" ]] && echo "must not be empty"
}

# :command.command_functions
# :command.function
slack_emoji_toolkit_upload_command() {
  # src/upload_command.sh
  curl_opts="-s"
  [[ -n "${args[--debug]}" ]] && {
    set -x
    curl_opts="-v ${curl_opts}"
  }

  images=$(find "${args[--source]}" -iname \*.gif -o -iname \*.png -o -iname \*.png -maxdepth 1)
  [[ "${images}" == "" ]] && {
    echo "$(red_bold [ERR]) the specified directory ${args[--source]} contains no images; exiting ..."
    exit 0
  }

  images_count=$(echo "${images}" | wc -l | tr -d ' ')
  confirm "Upload $(bold ${images_count}) image(s) to the target workspace $(bold ${args[--workspace-domain]})? [y/N]" || {
    exit 0
  }

  echo "${images}" | while read -r path; do

    name=$(basename "${path%.*}")

    echo -n "$(green [INF]) uploading $(bold ${path}) as $(bold :${args[--prefix]}${name}${args[--suffix]}:) ... "

    [[ -n ${args[--dry-run]} ]] && {
      echo 'skipping!'
      continue
    }

    result=$(
      curl ${curl_opts} --compressed "https://${args[--workspace-domain]}.slack.com/api/emoji.add" \
        -H 'content-type: multipart/form-data' \
        -H "cookie: d=${args[--cookie]};" \
        -F "token=${args[--token]}" \
        -F "name=${args[--prefix]}${name}${args[--suffix]}" \
        -F mode=data \
        -F "image=@${path}"

    )

    if [[ $(echo "${result}" | jq -r ".ok") == false ]]; then
      red "error!"
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) upload failed: ${error}"
    else
      echo 'done!'
    fi
  done

  echo "$(green [INF]) all done; exiting ..."
  exit 0
}

# :command.function
slack_emoji_toolkit_delete_command() {
  # src/delete_command.sh
  curl_opts="-s"
  [[ -n "${args[--debug]}" ]] && {
    set -x
    curl_opts="-v ${curl_opts}"
  }

  [[ -n "${args[--name]}" ]] && {
    confirm "$(yellow [???]) delete the emoji named $(bold :${args[--name]}:) from the target workspace $(bold ${args[--workspace-domain]})? [y/N]" || {
      exit 0
    }

    echo -n "$(green [INF]) removing $(bold :${args[--name]}:) from workspace ... "

    [[ -n ${args[--dry-run]} ]] && {
      echo 'skipping!'
      exit 0
    }

    result=$(
      curl ${curl_opts} --compressed "https://${args[--workspace-domain]}.slack.com/api/emoji.remove" \
        -H 'content-type: multipart/form-data' \
        -H "cookie: d=${args[--cookie]};" \
        -F "name=${args[--name]}" \
        -F "token=${args[--token]}"
    )

    if [[ $(echo "${result}" | jq -r ".ok") == false ]]; then
      red ' error!'
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) delete failed: ${error}"
    else
      echo ' deleted!'
    fi

    echo "$(green [INF]) all done; exiting ..."
    exit 0
  }

  field_user_ids=
  [[ -n "${args[--user-id]}" ]] && {
    user_ids=(${args[--user-id]})
    field_user_ids=$(join , "${user_ids[@]}")
  }

  field_queries=
  [[ -n "${args[--query]}" ]] && {
    queries=(${args[--query]})
    field_queries=$(join , "${queries[@]}")
  }

  to_delete=()
  page_current=1
  while true; do
    result=$(
      curl ${curl_opts} "https://${args[--workspace-domain]}.slack.com/api/emoji.adminList" \
        -H 'content-type: multipart/form-data' \
        -H "cookie: d=${args[--cookie]};" \
        -F "token=${args[--token]}" \
        -F "page=${page_current}" \
        -F "count=${args[--count]}" \
        -F "user_ids=[${field_user_ids}]" \
        -F "queries=[${field_queries}]"
    )

    [[ $(echo "${result}" | jq -r ".ok") == false ]] && {
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) request could not be completed: ${error}"
      exit 1
    }

    page_total=$(echo "${result}" | jq -r '.paging.pages')

    echo -n "$(green [INF]) fetching emojis from page $(bold ${page_current}) of $(bold ${page_total})..."
    for emoji in $(echo "${result}" | jq -r '.emoji[] | select(.is_alias == 0) | .name'); do
      to_delete+=("${emoji}")
    done

    echo ' done!'

    [[ "${page_current}" -ge "${page_total}" ]] && {
      echo "$(green [INF]) finished paging through results; moving on ..."
      break
    }

    ((page_current++))
  done

  [[ "${#to_delete[@]}" == 0 ]] && {
    echo "$(red_bold [ERR]) could not find any matching emojis; exiting ..."
    exit 1
  }

  confirm "$(yellow [???]) start deleting $(bold ${#to_delete[@]}) emoji(s) from the target workspace $(bold ${args[--workspace-domain]})? [y/N]" || {
    exit 0
  }

  for emoji in "${to_delete[@]}"; do
    [[ -z "${args[--nuke-from-orbit]}" ]] && {
      confirm "$(yellow [???]) are you sure you want to delete $(bold :${emoji}:) from the target workspace $(bold ${args[--workspace-domain]})? [y/N]" ]] || {
        continue
      }
    }

    echo -n "$(green [INF]) deleting $(bold :${emoji}:) ..."

    result=$(
      curl ${curl_opts} "https://${args[--workspace-domain]}.slack.com/api/emoji.remove" \
        -H "cookie: d=${args[--cookie]};" \
        -F "token=${args[--token]}" \
        -F "name=${emoji}"
    )

    if [[ $(echo "${result}" | jq -r ".ok") == false ]]; then
      red ' error!'
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) delete failed: ${error}"
    fi

    echo ' deleted!'
  done

  echo "$(green [INF]) all done; exiting ..."
  exit 0
}

# :command.function
slack_emoji_toolkit_download_command() {
  # src/download_command.sh
  curl_opts="-s"
  [[ -n "${args[--debug]}" ]] && {
    set -x
    curl_opts="-v ${curl_opts}"
  }

  payload=$(
    jq -nc \
      --arg     token "${args[--token]}" \
      --argjson count "${args[--count]}" \
      '{
        token: $token,

        count: $count
      }'
  )

  while true; do
    result=$(
      curl ${curl_opts} --compressed "https://edgeapi.slack.com/cache/${args[--workspace-id]}/emojis/list?fp=97" \
        -H "cookie: d=${args[--cookie]};" \
        --data-raw "${payload}"

    )

    [[ $(echo "${result}" | jq -r ".ok") == false ]] && {
      error=$(echo "${result}" | jq -r ".error")
      echo "$(red_bold [ERR]) request could not be completed: ${error}"
      exit 1
    }

    echo "${result}"  | jq -r '.results[] | select(.is_alias == null and (.value | type != "object")) | .value' | while read -r line; do

      name=$(basename $(dirname "${line}"))
      path="${args[--destination]}/${name}.${line##*.}"
      echo -n "$(green [INF]) saving $(bold :${name}:) to $(bold ${path}) ..."
      [[ -n ${args[--dry-run]} ]] && {
        echo ' skipping!'
        continue
      }

      curl ${curl_opts} -o  "${path}" "${line}"

      echo ' done!'
    done

    marker=$(echo "${result}" | jq -r ".next_marker")
    [[ "${marker}" == "null" ]] && break

    payload=$(echo "${payload}" | jq --arg marker "${marker}" '. + { marker: $marker }')
  done

  echo "$(green [INF]) all done; exiting ..."
  exit 0
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --version | -v )
    version_command
    exit
    ;;

  --help | -h )
    long_usage=yes
    slack_emoji_toolkit_usage
    exit
    ;;

  esac

  # :command.command_filter
  action=${1:-}

  case $action in
  -* )
    ;;

  upload )
    action="upload"
    shift
    slack_emoji_toolkit_upload_parse_requirements "$@"
    shift $#
    ;;

  delete )
    action="delete"
    shift
    slack_emoji_toolkit_delete_parse_requirements "$@"
    shift $#
    ;;

  download )
    action="download"
    shift
    slack_emoji_toolkit_download_parse_requirements "$@"
    shift $#
    ;;

  # :command.command_fallback
  "" )
    slack_emoji_toolkit_usage
    exit 1
    ;;

  * )
    printf "invalid command: %s\n" "$action"
    exit 1
    ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

}

# :command.parse_requirements
slack_emoji_toolkit_upload_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    slack_emoji_toolkit_upload_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --workspace-domain )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--workspace-domain]="$2"
        shift
        shift
      else
        printf "%s\n" "--workspace-domain requires an argument: --workspace-domain DOMAIN"
        exit 1
      fi
      ;;

    # :flag.case
    --workspace-id )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--workspace-id]="$2"
        shift
        shift
      else
        printf "%s\n" "--workspace-id requires an argument: --workspace-id ID"
        exit 1
      fi
      ;;

    # :flag.case
    --token )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--token]="$2"
        shift
        shift
      else
        printf "%s\n" "--token requires an argument: --token TOKEN"
        exit 1
      fi
      ;;

    # :flag.case
    --cookie )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--cookie]="$2"
        shift
        shift
      else
        printf "%s\n" "--cookie requires an argument: --cookie COOKIE"
        exit 1
      fi
      ;;

    # :flag.case
    --source )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_dir_exists "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--source SOURCE" "$(validate_dir_exists "$2")"
          exit 1
        fi

        args[--source]="$2"
        shift
        shift
      else
        printf "%s\n" "--source requires an argument: --source SOURCE"
        exit 1
      fi
      ;;

    # :flag.case
    --prefix )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--prefix]="$2"
        shift
        shift
      else
        printf "%s\n" "--prefix requires an argument: --prefix PREFIX"
        exit 1
      fi
      ;;

    # :flag.case
    --suffix )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--suffix]="$2"
        shift
        shift
      else
        printf "%s\n" "--suffix requires an argument: --suffix SUFFIX"
        exit 1
      fi
      ;;

    # :flag.case
    --dry-run )

      # :flag.case_no_arg
      args[--dry-run]=1
      shift
      ;;

    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args[--workspace-domain]+x} ]]; then
    printf "missing required flag: --workspace-domain DOMAIN\n"
    exit 1
  fi
  if [[ -z ${args[--workspace-id]+x} ]]; then
    printf "missing required flag: --workspace-id ID\n"
    exit 1
  fi
  if [[ -z ${args[--token]+x} ]]; then
    printf "missing required flag: --token TOKEN\n"
    exit 1
  fi
  if [[ -z ${args[--cookie]+x} ]]; then
    printf "missing required flag: --cookie COOKIE\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--source]:-} ]] || args[--source]="."

}

# :command.parse_requirements
slack_emoji_toolkit_delete_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    slack_emoji_toolkit_delete_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --workspace-domain )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--workspace-domain]="$2"
        shift
        shift
      else
        printf "%s\n" "--workspace-domain requires an argument: --workspace-domain DOMAIN"
        exit 1
      fi
      ;;

    # :flag.case
    --token )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--token]="$2"
        shift
        shift
      else
        printf "%s\n" "--token requires an argument: --token TOKEN"
        exit 1
      fi
      ;;

    # :flag.case
    --cookie )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--cookie]="$2"
        shift
        shift
      else
        printf "%s\n" "--cookie requires an argument: --cookie COOKIE"
        exit 1
      fi
      ;;

    # :flag.case
    --query )
      # :flag.conflicts
      if [[ -n "${args[--name]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--name"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        if [[ -z ${args[--query]+x} ]]; then
          args[--query]="\"$2\""
        else
          args[--query]="${args[--query]} \"$2\""
        fi
        shift
        shift
      else
        printf "%s\n" "--query requires an argument: --query QUERIES"
        exit 1
      fi
      ;;

    # :flag.case
    --user-id )
      # :flag.conflicts
      if [[ -n "${args[--name]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--name"
        exit 1
      fi

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        if [[ -z ${args[--user-id]+x} ]]; then
          args[--user-id]="\"$2\""
        else
          args[--user-id]="${args[--user-id]} \"$2\""
        fi
        shift
        shift
      else
        printf "%s\n" "--user-id requires an argument: --user-id USERS"
        exit 1
      fi
      ;;

    # :flag.case
    --name )
      # :flag.conflicts
      for conflict in --query --user-id; do
        if [[ -n "${args[$conflict]:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "$conflict"
          exit 1
        fi
      done

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--name]="$2"
        shift
        shift
      else
        printf "%s\n" "--name requires an argument: --name NAME"
        exit 1
      fi
      ;;

    # :flag.case
    --count )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_integer "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--count COUNT" "$(validate_integer "$2")"
          exit 1
        fi

        args[--count]="$2"
        shift
        shift
      else
        printf "%s\n" "--count requires an argument: --count COUNT"
        exit 1
      fi
      ;;

    # :flag.case
    --nuke-from-orbit )
      # :flag.conflicts
      if [[ -n "${args[--name]:-}" ]]; then
        printf "conflicting options: %s cannot be used with %s\n" "$key" "--name"
        exit 1
      fi

      # :flag.case_no_arg
      args[--nuke-from-orbit]=1
      shift
      ;;

    # :flag.case
    --dry-run )

      # :flag.case_no_arg
      args[--dry-run]=1
      shift
      ;;

    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args[--workspace-domain]+x} ]]; then
    printf "missing required flag: --workspace-domain DOMAIN\n"
    exit 1
  fi
  if [[ -z ${args[--token]+x} ]]; then
    printf "missing required flag: --token TOKEN\n"
    exit 1
  fi
  if [[ -z ${args[--cookie]+x} ]]; then
    printf "missing required flag: --cookie COOKIE\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--count]:-} ]] || args[--count]="10"

}

# :command.parse_requirements
slack_emoji_toolkit_download_parse_requirements() {
  # :command.fixed_flags_filter
  case "${1:-}" in
  --help | -h )
    long_usage=yes
    slack_emoji_toolkit_download_usage
    exit
    ;;

  esac

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --workspace-id )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--workspace-id]="$2"
        shift
        shift
      else
        printf "%s\n" "--workspace-id requires an argument: --workspace-id ID"
        exit 1
      fi
      ;;

    # :flag.case
    --token )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--token]="$2"
        shift
        shift
      else
        printf "%s\n" "--token requires an argument: --token TOKEN"
        exit 1
      fi
      ;;

    # :flag.case
    --cookie )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then

        args[--cookie]="$2"
        shift
        shift
      else
        printf "%s\n" "--cookie requires an argument: --cookie COOKIE"
        exit 1
      fi
      ;;

    # :flag.case
    --count )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_integer "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--count COUNT" "$(validate_integer "$2")"
          exit 1
        fi

        args[--count]="$2"
        shift
        shift
      else
        printf "%s\n" "--count requires an argument: --count COUNT"
        exit 1
      fi
      ;;

    # :flag.case
    --destination )

      # :flag.case_arg
      if [[ -n ${2+x} ]]; then
        # :flag.validations
        if [[ -n $(validate_dir_exists "$2") ]]; then
          printf "validation error in %s:\n%s\n" "--destination DESTINATION" "$(validate_dir_exists "$2")"
          exit 1
        fi

        args[--destination]="$2"
        shift
        shift
      else
        printf "%s\n" "--destination requires an argument: --destination DESTINATION"
        exit 1
      fi
      ;;

    # :flag.case
    --dry-run )

      # :flag.case_no_arg
      args[--dry-run]=1
      shift
      ;;

    # :flag.case
    --debug )

      # :flag.case_no_arg
      args[--debug]=1
      shift
      ;;

    -?* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;

    * )
      # :command.parse_requirements_case
      # :command.parse_requirements_case_simple
      printf "invalid argument: %s\n" "$key"
      exit 1

      ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args[--workspace-id]+x} ]]; then
    printf "missing required flag: --workspace-id ID\n"
    exit 1
  fi
  if [[ -z ${args[--token]+x} ]]; then
    printf "missing required flag: --token TOKEN\n"
    exit 1
  fi
  if [[ -z ${args[--cookie]+x} ]]; then
    printf "missing required flag: --cookie COOKIE\n"
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args[--count]:-} ]] || args[--count]="10"
  [[ -n ${args[--destination]:-} ]] || args[--destination]="."

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # src/initialize.sh
  set -eo pipefail

  if ! command -v "jq" &> /dev/null; then
    echo "$(red_bold [ERR]) jq could not be located. Install using the relevant command:"
    echo "$(red_bold [ERR])   MacOS: $ brew update && brew install jq"
    echo "$(red_bold [ERR])   Linux: $ apt-get install jq"
    exit 1
  fi
}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "upload" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      slack_emoji_toolkit_upload_usage
    else
      slack_emoji_toolkit_upload_command
    fi

  elif [[ $action == "delete" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      slack_emoji_toolkit_delete_usage
    else
      slack_emoji_toolkit_delete_command
    fi

  elif [[ $action == "download" ]]; then
    if [[ ${args[--help]:-} ]]; then
      long_usage=yes
      slack_emoji_toolkit_download_usage
    else
      slack_emoji_toolkit_download_command
    fi

  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
